<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - ReactDOMComponent.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>ReactDOMComponent.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.58</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">948</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">69.87</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.08</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMComponent
 * @typechecks static-only
 */

/* global hasOwnProperty:true */

&#039;use strict&#039;;

var AutoFocusUtils = require(&#039;./AutoFocusUtils&#039;);
var CSSPropertyOperations = require(&#039;./CSSPropertyOperations&#039;);
var DOMProperty = require(&#039;./DOMProperty&#039;);
var DOMPropertyOperations = require(&#039;./DOMPropertyOperations&#039;);
var EventConstants = require(&#039;./EventConstants&#039;);
var ReactBrowserEventEmitter = require(&#039;./ReactBrowserEventEmitter&#039;);
var ReactComponentBrowserEnvironment = require(&#039;./ReactComponentBrowserEnvironment&#039;);
var ReactDOMButton = require(&#039;./ReactDOMButton&#039;);
var ReactDOMInput = require(&#039;./ReactDOMInput&#039;);
var ReactDOMOption = require(&#039;./ReactDOMOption&#039;);
var ReactDOMSelect = require(&#039;./ReactDOMSelect&#039;);
var ReactDOMTextarea = require(&#039;./ReactDOMTextarea&#039;);
var ReactMount = require(&#039;./ReactMount&#039;);
var ReactMultiChild = require(&#039;./ReactMultiChild&#039;);
var ReactPerf = require(&#039;./ReactPerf&#039;);
var ReactUpdateQueue = require(&#039;./ReactUpdateQueue&#039;);

var assign = require(&#039;./Object.assign&#039;);
var canDefineProperty = require(&#039;./canDefineProperty&#039;);
var escapeTextContentForBrowser = require(&#039;./escapeTextContentForBrowser&#039;);
var invariant = require(&#039;fbjs/lib/invariant&#039;);
var isEventSupported = require(&#039;./isEventSupported&#039;);
var keyOf = require(&#039;fbjs/lib/keyOf&#039;);
var setInnerHTML = require(&#039;./setInnerHTML&#039;);
var setTextContent = require(&#039;./setTextContent&#039;);
var shallowEqual = require(&#039;fbjs/lib/shallowEqual&#039;);
var validateDOMNesting = require(&#039;./validateDOMNesting&#039;);
var warning = require(&#039;fbjs/lib/warning&#039;);

var deleteListener = ReactBrowserEventEmitter.deleteListener;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { &#039;string&#039;: true, &#039;number&#039;: true };

var CHILDREN = keyOf({ children: null });
var STYLE = keyOf({ style: null });
var HTML = keyOf({ __html: null });

var ELEMENT_NODE_TYPE = 1;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return &#039; This DOM node was rendered by `&#039; + name + &#039;`.&#039;;
      }
    }
  }
  return &#039;&#039;;
}

var legacyPropsDescriptor;
if (process.env.NODE_ENV !== &#039;production&#039;) {
  legacyPropsDescriptor = {
    props: {
      enumerable: false,
      get: function () {
        var component = this._reactInternalComponent;
        process.env.NODE_ENV !== &#039;production&#039; ? warning(false, &#039;ReactDOMComponent: Do not access .props of a DOM node; instead, &#039; + &#039;recreate the props as `render` did originally or read the DOM &#039; + &#039;properties/attributes directly from this node (e.g., &#039; + &#039;this.refs.box.className).%s&#039;, getDeclarationErrorAddendum(component)) : undefined;
        return component._currentElement.props;
      }
    }
  };
}

function legacyGetDOMNode() {
  if (process.env.NODE_ENV !== &#039;production&#039;) {
    var component = this._reactInternalComponent;
    process.env.NODE_ENV !== &#039;production&#039; ? warning(false, &#039;ReactDOMComponent: Do not access .getDOMNode() of a DOM node; &#039; + &#039;instead, use the node directly.%s&#039;, getDeclarationErrorAddendum(component)) : undefined;
  }
  return this;
}

function legacyIsMounted() {
  var component = this._reactInternalComponent;
  if (process.env.NODE_ENV !== &#039;production&#039;) {
    process.env.NODE_ENV !== &#039;production&#039; ? warning(false, &#039;ReactDOMComponent: Do not access .isMounted() of a DOM node.%s&#039;, getDeclarationErrorAddendum(component)) : undefined;
  }
  return !!component;
}

function legacySetStateEtc() {
  if (process.env.NODE_ENV !== &#039;production&#039;) {
    var component = this._reactInternalComponent;
    process.env.NODE_ENV !== &#039;production&#039; ? warning(false, &#039;ReactDOMComponent: Do not access .setState(), .replaceState(), or &#039; + &#039;.forceUpdate() of a DOM node. This is a no-op.%s&#039;, getDeclarationErrorAddendum(component)) : undefined;
  }
}

function legacySetProps(partialProps, callback) {
  var component = this._reactInternalComponent;
  if (process.env.NODE_ENV !== &#039;production&#039;) {
    process.env.NODE_ENV !== &#039;production&#039; ? warning(false, &#039;ReactDOMComponent: Do not access .setProps() of a DOM node. &#039; + &#039;Instead, call ReactDOM.render again at the top level.%s&#039;, getDeclarationErrorAddendum(component)) : undefined;
  }
  if (!component) {
    return;
  }
  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
  if (callback) {
    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
  }
}

function legacyReplaceProps(partialProps, callback) {
  var component = this._reactInternalComponent;
  if (process.env.NODE_ENV !== &#039;production&#039;) {
    process.env.NODE_ENV !== &#039;production&#039; ? warning(false, &#039;ReactDOMComponent: Do not access .replaceProps() of a DOM node. &#039; + &#039;Instead, call ReactDOM.render again at the top level.%s&#039;, getDeclarationErrorAddendum(component)) : undefined;
  }
  if (!component) {
    return;
  }
  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
  if (callback) {
    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
  }
}

function friendlyStringify(obj) {
  if (typeof obj === &#039;object&#039;) {
    if (Array.isArray(obj)) {
      return &#039;[&#039; + obj.map(friendlyStringify).join(&#039;, &#039;) + &#039;]&#039;;
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + &#039;: &#039; + friendlyStringify(obj[key]));
        }
      }
      return &#039;{&#039; + pairs.join(&#039;, &#039;) + &#039;}&#039;;
    }
  } else if (typeof obj === &#039;string&#039;) {
    return JSON.stringify(obj);
  } else if (typeof obj === &#039;function&#039;) {
    return &#039;[function object]&#039;;
  }
  // Differs from JSON.stringify in that undefined becauses undefined and that
  // inf and nan don&#039;t become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + &#039;|&#039; + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  process.env.NODE_ENV !== &#039;production&#039; ? warning(false, &#039;`%s` was passed a style object that has previously been mutated. &#039; + &#039;Mutating `style` is deprecated. Consider cloning it beforehand. Check &#039; + &#039;the `render` %s. Previous style: %s. Mutated style: %s.&#039;, componentName, owner ? &#039;of `&#039; + ownerName + &#039;`&#039; : &#039;using &lt;&#039; + componentName + &#039;&gt;&#039;, friendlyStringify(style1), friendlyStringify(style2)) : undefined;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (process.env.NODE_ENV !== &#039;production&#039;) {
    if (voidElementTags[component._tag]) {
      process.env.NODE_ENV !== &#039;production&#039; ? warning(props.children == null &amp;&amp; props.dangerouslySetInnerHTML == null, &#039;%s is a void element tag and must not have `children` or &#039; + &#039;use `props.dangerouslySetInnerHTML`.%s&#039;, component._tag, component._currentElement._owner ? &#039; Check the render method of &#039; + component._currentElement._owner.getName() + &#039;.&#039; : &#039;&#039;) : undefined;
    }
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? process.env.NODE_ENV !== &#039;production&#039; ? invariant(false, &#039;Can only set one of `children` or `props.dangerouslySetInnerHTML`.&#039;) : invariant(false) : undefined;
    !(typeof props.dangerouslySetInnerHTML === &#039;object&#039; &amp;&amp; HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== &#039;production&#039; ? invariant(false, &#039;`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. &#039; + &#039;Please visit https://fb.me/react-invariant-dangerously-set-inner-html &#039; + &#039;for more information.&#039;) : invariant(false) : undefined;
  }
  if (process.env.NODE_ENV !== &#039;production&#039;) {
    process.env.NODE_ENV !== &#039;production&#039; ? warning(props.innerHTML == null, &#039;Directly setting property `innerHTML` is not permitted. &#039; + &#039;For more information, lookup documentation on `dangerouslySetInnerHTML`.&#039;) : undefined;
    process.env.NODE_ENV !== &#039;production&#039; ? warning(!props.contentEditable || props.children == null, &#039;A component is `contentEditable` and contains `children` managed by &#039; + &#039;React. It is now your responsibility to guarantee that none of &#039; + &#039;those nodes are unexpectedly modified or duplicated. This is &#039; + &#039;probably not intentional.&#039;) : undefined;
  }
  !(props.style == null || typeof props.style === &#039;object&#039;) ? process.env.NODE_ENV !== &#039;production&#039; ? invariant(false, &#039;The `style` prop expects a mapping from style properties to values, &#039; + &#039;not a string. For example, style={{marginRight: spacing + \&#039;em\&#039;}} when &#039; + &#039;using JSX.%s&#039;, getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
}

function enqueuePutListener(id, registrationName, listener, transaction) {
  if (process.env.NODE_ENV !== &#039;production&#039;) {
    // IE8 has no API for event capturing and the `onScroll` event doesn&#039;t
    // bubble.
    process.env.NODE_ENV !== &#039;production&#039; ? warning(registrationName !== &#039;onScroll&#039; || isEventSupported(&#039;scroll&#039;, true), &#039;This browser doesn\&#039;t support the `onScroll` event&#039;) : undefined;
  }
  var container = ReactMount.findReactContainerForID(id);
  if (container) {
    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
    listenTo(registrationName, doc);
  }
  transaction.getReactMountReady().enqueue(putListener, {
    id: id,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: &#039;abort&#039;,
  topCanPlay: &#039;canplay&#039;,
  topCanPlayThrough: &#039;canplaythrough&#039;,
  topDurationChange: &#039;durationchange&#039;,
  topEmptied: &#039;emptied&#039;,
  topEncrypted: &#039;encrypted&#039;,
  topEnded: &#039;ended&#039;,
  topError: &#039;error&#039;,
  topLoadedData: &#039;loadeddata&#039;,
  topLoadedMetadata: &#039;loadedmetadata&#039;,
  topLoadStart: &#039;loadstart&#039;,
  topPause: &#039;pause&#039;,
  topPlay: &#039;play&#039;,
  topPlaying: &#039;playing&#039;,
  topProgress: &#039;progress&#039;,
  topRateChange: &#039;ratechange&#039;,
  topSeeked: &#039;seeked&#039;,
  topSeeking: &#039;seeking&#039;,
  topStalled: &#039;stalled&#039;,
  topSuspend: &#039;suspend&#039;,
  topTimeUpdate: &#039;timeupdate&#039;,
  topVolumeChange: &#039;volumechange&#039;,
  topWaiting: &#039;waiting&#039;
};

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? process.env.NODE_ENV !== &#039;production&#039; ? invariant(false, &#039;Must be mounted to trap events&#039;) : invariant(false) : undefined;
  var node = ReactMount.getNode(inst._rootNodeID);
  !node ? process.env.NODE_ENV !== &#039;production&#039; ? invariant(false, &#039;trapBubbledEvent(...): Requires node to be rendered.&#039;) : invariant(false) : undefined;

  switch (inst._tag) {
    case &#039;iframe&#039;:
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, &#039;load&#039;, node)];
      break;
    case &#039;video&#039;:
    case &#039;audio&#039;:

      inst._wrapperState.listeners = [];
      // create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
        }
      }

      break;
    case &#039;img&#039;:
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, &#039;error&#039;, node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, &#039;load&#039;, node)];
      break;
    case &#039;form&#039;:
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, &#039;reset&#039;, node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, &#039;submit&#039;, node)];
      break;
  }
}

function mountReadyInputWrapper() {
  ReactDOMInput.mountReadyWrapper(this);
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special cased tags.

var omittedCloseTags = {
  &#039;area&#039;: true,
  &#039;base&#039;: true,
  &#039;br&#039;: true,
  &#039;col&#039;: true,
  &#039;embed&#039;: true,
  &#039;hr&#039;: true,
  &#039;img&#039;: true,
  &#039;input&#039;: true,
  &#039;keygen&#039;: true,
  &#039;link&#039;: true,
  &#039;meta&#039;: true,
  &#039;param&#039;: true,
  &#039;source&#039;: true,
  &#039;track&#039;: true,
  &#039;wbr&#039;: true
};

// NOTE: menuitem&#039;s close tag should be omitted, but that causes problems.
var newlineEatingTags = {
  &#039;listing&#039;: true,
  &#039;pre&#039;: true,
  &#039;textarea&#039;: true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = assign({
  &#039;menuitem&#039;: true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it&#039;s a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = ({}).hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== &#039;production&#039; ? invariant(false, &#039;Invalid tag: %s&#039;, tag) : invariant(false) : undefined;
    validatedTagCache[tag] = true;
  }
}

function processChildContextDev(context, inst) {
  // Pass down our tag name to child components for validation purposes
  context = assign({}, context);
  var info = context[validateDOMNesting.ancestorInfoContextKey];
  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
  return context;
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf(&#039;-&#039;) &gt;= 0 || props.is != null;
}

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(tag) {
  validateDangerousTag(tag);
  this._tag = tag.toLowerCase();
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._rootNodeID = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._nodeWithLegacyProperties = null;
  if (process.env.NODE_ENV !== &#039;production&#039;) {
    this._unprocessedContextDev = null;
    this._processedContextDev = null;
  }
}

ReactDOMComponent.displayName = &#039;ReactDOMComponent&#039;;

ReactDOMComponent.Mixin = {

  construct: function (element) {
    this._currentElement = element;
  },

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {string} rootID The root DOM ID for this node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (rootID, transaction, context) {
    this._rootNodeID = rootID;

    var props = this._currentElement.props;

    switch (this._tag) {
      case &#039;iframe&#039;:
      case &#039;img&#039;:
      case &#039;form&#039;:
      case &#039;video&#039;:
      case &#039;audio&#039;:
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case &#039;button&#039;:
        props = ReactDOMButton.getNativeProps(this, props, context);
        break;
      case &#039;input&#039;:
        ReactDOMInput.mountWrapper(this, props, context);
        props = ReactDOMInput.getNativeProps(this, props, context);
        break;
      case &#039;option&#039;:
        ReactDOMOption.mountWrapper(this, props, context);
        props = ReactDOMOption.getNativeProps(this, props, context);
        break;
      case &#039;select&#039;:
        ReactDOMSelect.mountWrapper(this, props, context);
        props = ReactDOMSelect.getNativeProps(this, props, context);
        context = ReactDOMSelect.processChildContext(this, props, context);
        break;
      case &#039;textarea&#039;:
        ReactDOMTextarea.mountWrapper(this, props, context);
        props = ReactDOMTextarea.getNativeProps(this, props, context);
        break;
    }

    assertValidProps(this, props);
    if (process.env.NODE_ENV !== &#039;production&#039;) {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    if (process.env.NODE_ENV !== &#039;production&#039;) {
      this._unprocessedContextDev = context;
      this._processedContextDev = processChildContextDev(context, this);
      context = this._processedContextDev;
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
      var el = ownerDocument.createElement(this._currentElement.type);
      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
      // Populate node cache
      ReactMount.getID(el);
      this._updateDOMProperties({}, props, transaction, el);
      this._createInitialChildren(transaction, props, context, el);
      mountImage = el;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent &amp;&amp; omittedCloseTags[this._tag]) {
        mountImage = tagOpen + &#039;/&gt;&#039;;
      } else {
        mountImage = tagOpen + &#039;&gt;&#039; + tagContent + &#039;&lt;/&#039; + this._currentElement.type + &#039;&gt;&#039;;
      }
    }

    switch (this._tag) {
      case &#039;input&#039;:
        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
      // falls through
      case &#039;button&#039;:
      case &#039;select&#039;:
      case &#039;textarea&#039;:
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = &#039;&lt;&#039; + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if (process.env.NODE_ENV !== &#039;production&#039;) {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
        }
        var markup = null;
        if (this._tag != null &amp;&amp; isCustomComponent(this._tag, props)) {
          if (propKey !== CHILDREN) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += &#039; &#039; + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
    return ret + &#039; &#039; + markupForID;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = &#039;&#039;;

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join(&#039;&#039;);
      }
    }
    if (newlineEatingTags[this._tag] &amp;&amp; ret.charAt(0) === &#039;\n&#039;) {
      // text/html ignores the first character in these tags if it&#039;s a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing &quot;^\n&quot; with &quot;\r\n&quot; doesn&#039;t get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: &lt;http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre&gt;
      // See: &lt;http://www.w3.org/TR/html5/syntax.html#element-restrictions&gt;
      // See: &lt;http://www.w3.org/TR/html5/syntax.html#newlines&gt;
      // See: Parsing of &quot;textarea&quot; &quot;listing&quot; and &quot;pre&quot; elements
      //  from &lt;http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody&gt;
      return &#039;\n&#039; + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, el) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        setInnerHTML(el, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        setTextContent(el, contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i &lt; mountImages.length; i++) {
          el.appendChild(mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a native DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case &#039;button&#039;:
        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
        break;
      case &#039;input&#039;:
        ReactDOMInput.updateWrapper(this);
        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
        break;
      case &#039;option&#039;:
        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
        break;
      case &#039;select&#039;:
        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
        break;
      case &#039;textarea&#039;:
        ReactDOMTextarea.updateWrapper(this);
        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
        break;
    }

    if (process.env.NODE_ENV !== &#039;production&#039;) {
      // If the context is reference-equal to the old one, pass down the same
      // processed object so the update bailout in ReactReconciler behaves
      // correctly (and identically in dev and prod). See #5005.
      if (this._unprocessedContextDev !== context) {
        this._unprocessedContextDev = context;
        this._processedContextDev = processChildContextDev(context, this);
      }
      context = this._processedContextDev;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction, null);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    if (!canDefineProperty &amp;&amp; this._nodeWithLegacyProperties) {
      this._nodeWithLegacyProperties.props = nextProps;
    }

    if (this._tag === &#039;select&#039;) {
      // &lt;select&gt; value update needs to occur after &lt;option&gt; children
      // reconciliation
      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction, node) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = &#039;&#039;;
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn&#039;t actually a
          // listener (e.g., onClick={null})
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        DOMPropertyOperations.deleteValueForProperty(node, propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if (process.env.NODE_ENV !== &#039;production&#039;) {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) &amp;&amp; (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = &#039;&#039;;
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        if (propKey === CHILDREN) {
          nextProp = null;
        }
        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        // If we&#039;re updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertantly setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      if (!node) {
        node = ReactMount.getNode(this._rootNodeID);
      }
      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML &amp;&amp; lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML &amp;&amp; nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we&#039;re switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null &amp;&amp; nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml &amp;&amp; !nextHasContentOrHtml) {
      this.updateTextContent(&#039;&#039;);
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent(&#039;&#039; + nextContent);
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup(&#039;&#039; + nextHtml);
      }
    } else if (nextChildren != null) {
      this.updateChildren(nextChildren, transaction, context);
    }
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function () {
    switch (this._tag) {
      case &#039;iframe&#039;:
      case &#039;img&#039;:
      case &#039;form&#039;:
      case &#039;video&#039;:
      case &#039;audio&#039;:
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i &lt; listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case &#039;input&#039;:
        ReactDOMInput.unmountWrapper(this);
        break;
      case &#039;html&#039;:
      case &#039;head&#039;:
      case &#039;body&#039;:
        /**
         * Components like &lt;html&gt; &lt;head&gt; and &lt;body&gt; can&#039;t be removed or added
         * easily in a cross-browser way, however it&#039;s valuable to be able to
         * take advantage of React&#039;s reconciliation for styling and &lt;title&gt;
         * management. So we just document it and throw in dangerous cases.
         */
        !false ? process.env.NODE_ENV !== &#039;production&#039; ? invariant(false, &#039;&lt;%s&gt; tried to unmount. Because of cross-browser quirks it is &#039; + &#039;impossible to unmount some top-level components (eg &lt;html&gt;, &#039; + &#039;&lt;head&gt;, and &lt;body&gt;) reliably and efficiently. To fix this, have a &#039; + &#039;single top-level component that never unmounts render these &#039; + &#039;elements.&#039;, this._tag) : invariant(false) : undefined;
        break;
    }

    this.unmountChildren();
    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
    this._rootNodeID = null;
    this._wrapperState = null;
    if (this._nodeWithLegacyProperties) {
      var node = this._nodeWithLegacyProperties;
      node._reactInternalComponent = null;
      this._nodeWithLegacyProperties = null;
    }
  },

  getPublicInstance: function () {
    if (!this._nodeWithLegacyProperties) {
      var node = ReactMount.getNode(this._rootNodeID);

      node._reactInternalComponent = this;
      node.getDOMNode = legacyGetDOMNode;
      node.isMounted = legacyIsMounted;
      node.setState = legacySetStateEtc;
      node.replaceState = legacySetStateEtc;
      node.forceUpdate = legacySetStateEtc;
      node.setProps = legacySetProps;
      node.replaceProps = legacyReplaceProps;

      if (process.env.NODE_ENV !== &#039;production&#039;) {
        if (canDefineProperty) {
          Object.defineProperties(node, legacyPropsDescriptor);
        } else {
          // updateComponent will update this property on subsequent renders
          node.props = this._currentElement.props;
        }
      } else {
        // updateComponent will update this property on subsequent renders
        node.props = this._currentElement.props;
      }

      this._nodeWithLegacyProperties = node;
    }
    return this._nodeWithLegacyProperties;
  }

};

ReactPerf.measureMethods(ReactDOMComponent, &#039;ReactDOMComponent&#039;, {
  mountComponent: &#039;mountComponent&#039;,
  updateComponent: &#039;updateComponent&#039;
});

assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
