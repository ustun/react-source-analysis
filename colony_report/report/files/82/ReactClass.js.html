<h1>ReactClass.js</h1>
<pre><code class="lang-js"><span class="comment">/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactClass
 */</span>

<span class="string">'use strict'</span>;

<span class="keyword">var</span> ReactComponent = require(<span class="string">'./ReactComponent'</span>);
<span class="keyword">var</span> ReactElement = require(<span class="string">'./ReactElement'</span>);
<span class="keyword">var</span> ReactPropTypeLocations = require(<span class="string">'./ReactPropTypeLocations'</span>);
<span class="keyword">var</span> ReactPropTypeLocationNames = require(<span class="string">'./ReactPropTypeLocationNames'</span>);
<span class="keyword">var</span> ReactNoopUpdateQueue = require(<span class="string">'./ReactNoopUpdateQueue'</span>);

<span class="keyword">var</span> assign = require(<span class="string">'./Object.assign'</span>);
<span class="keyword">var</span> emptyObject = require(<span class="string">'fbjs/lib/emptyObject'</span>);
<span class="keyword">var</span> invariant = require(<span class="string">'fbjs/lib/invariant'</span>);
<span class="keyword">var</span> keyMirror = require(<span class="string">'fbjs/lib/keyMirror'</span>);
<span class="keyword">var</span> keyOf = require(<span class="string">'fbjs/lib/keyOf'</span>);
<span class="keyword">var</span> warning = require(<span class="string">'fbjs/lib/warning'</span>);

<span class="keyword">var</span> MIXINS_KEY = keyOf({ mixins: <span class="literal">null</span> });

<span class="comment">/**
 * Policies that describe methods in `ReactClassInterface`.
 */</span>
<span class="keyword">var</span> SpecPolicy = keyMirror({
  <span class="comment">/**
   * These methods may be defined only once by the class specification or mixin.
   */</span>
  DEFINE_ONCE: <span class="literal">null</span>,
  <span class="comment">/**
   * These methods may be defined by both the class specification and mixins.
   * Subsequent definitions will be chained. These methods must return void.
   */</span>
  DEFINE_MANY: <span class="literal">null</span>,
  <span class="comment">/**
   * These methods are overriding the base class.
   */</span>
  OVERRIDE_BASE: <span class="literal">null</span>,
  <span class="comment">/**
   * These methods are similar to DEFINE_MANY, except we assume they return
   * objects. We try to merge the keys of the return values of all the mixed in
   * functions. If there is a key conflict we throw.
   */</span>
  DEFINE_MANY_MERGED: <span class="literal">null</span>
});

<span class="keyword">var</span> injectedMixins = [];

<span class="keyword">var</span> warnedSetProps = <span class="literal">false</span>;
<span class="function"><span class="keyword">function</span> <span class="title">warnSetProps</span><span class="params">()</span> {</span>
  <span class="keyword">if</span> (!warnedSetProps) {
    warnedSetProps = <span class="literal">true</span>;
    process.env.NODE_ENV !== <span class="string">'production'</span> ? warning(<span class="literal">false</span>, <span class="string">'setProps(...) and replaceProps(...) are deprecated. '</span> + <span class="string">'Instead, call render again at the top level.'</span>) : <span class="literal">undefined</span>;
  }
}

<span class="comment">/**
 * Composite components are higher-level components that compose other composite
 * or native components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return &lt;div>Hello World&lt;/div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */</span>
<span class="keyword">var</span> ReactClassInterface = {

  <span class="comment">/**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */</span>
  mixins: SpecPolicy.DEFINE_MANY,

  <span class="comment">/**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */</span>
  statics: SpecPolicy.DEFINE_MANY,

  <span class="comment">/**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */</span>
  propTypes: SpecPolicy.DEFINE_MANY,

  <span class="comment">/**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */</span>
  contextTypes: SpecPolicy.DEFINE_MANY,

  <span class="comment">/**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */</span>
  childContextTypes: SpecPolicy.DEFINE_MANY,

  <span class="comment">// ==== Definition methods ====</span>

  <span class="comment">/**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */</span>
  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

  <span class="comment">/**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */</span>
  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

  <span class="comment">/**
   * @return {object}
   * @optional
   */</span>
  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

  <span class="comment">/**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return &lt;div>Hello, {name}!&lt;/div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */</span>
  render: SpecPolicy.DEFINE_ONCE,

  <span class="comment">// ==== Delegate methods ====</span>

  <span class="comment">/**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */</span>
  componentWillMount: SpecPolicy.DEFINE_MANY,

  <span class="comment">/**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */</span>
  componentDidMount: SpecPolicy.DEFINE_MANY,

  <span class="comment">/**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */</span>
  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

  <span class="comment">/**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */</span>
  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

  <span class="comment">/**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */</span>
  componentWillUpdate: SpecPolicy.DEFINE_MANY,

  <span class="comment">/**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */</span>
  componentDidUpdate: SpecPolicy.DEFINE_MANY,

  <span class="comment">/**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */</span>
  componentWillUnmount: SpecPolicy.DEFINE_MANY,

  <span class="comment">// ==== Advanced methods ====</span>

  <span class="comment">/**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */</span>
  updateComponent: SpecPolicy.OVERRIDE_BASE

};

<span class="comment">/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */</span>
<span class="keyword">var</span> RESERVED_SPEC_KEYS = {
  displayName: <span class="function"><span class="keyword">function</span> <span class="params">(Constructor, displayName)</span> {</span>
    Constructor.displayName = displayName;
  },
  mixins: <span class="function"><span class="keyword">function</span> <span class="params">(Constructor, mixins)</span> {</span>
    <span class="keyword">if</span> (mixins) {
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: <span class="function"><span class="keyword">function</span> <span class="params">(Constructor, childContextTypes)</span> {</span>
    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
    }
    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: <span class="function"><span class="keyword">function</span> <span class="params">(Constructor, contextTypes)</span> {</span>
    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
    }
    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
  },
  <span class="comment">/**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */</span>
  getDefaultProps: <span class="function"><span class="keyword">function</span> <span class="params">(Constructor, getDefaultProps)</span> {</span>
    <span class="keyword">if</span> (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } <span class="keyword">else</span> {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: <span class="function"><span class="keyword">function</span> <span class="params">(Constructor, propTypes)</span> {</span>
    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
    }
    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
  },
  statics: <span class="function"><span class="keyword">function</span> <span class="params">(Constructor, statics)</span> {</span>
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>} };

<span class="comment">// noop</span>
<span class="function"><span class="keyword">function</span> <span class="title">validateTypeDef</span><span class="params">(Constructor, typeDef, location)</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> typeDef) {
    <span class="keyword">if</span> (typeDef.hasOwnProperty(propName)) {
      <span class="comment">// use a warning instead of an invariant so components</span>
      <span class="comment">// don't show up in prod but not in __DEV__</span>
      process.env.NODE_ENV !== <span class="string">'production'</span> ? warning(<span class="keyword">typeof</span> typeDef[propName] === <span class="string">'function'</span>, <span class="string">'%s: %s type `%s` is invalid; it must be a function, usually from '</span> + <span class="string">'React.PropTypes.'</span>, Constructor.displayName || <span class="string">'ReactClass'</span>, ReactPropTypeLocationNames[location], propName) : <span class="literal">undefined</span>;
    }
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">validateMethodOverride</span><span class="params">(proto, name)</span> {</span>
  <span class="keyword">var</span> specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : <span class="literal">null</span>;

  <span class="comment">// Disallow overriding of base class methods unless explicitly allowed.</span>
  <span class="keyword">if</span> (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'ReactClassInterface: You are attempting to override '</span> + <span class="string">'`%s` from your class specification. Ensure that your method names '</span> + <span class="string">'do not overlap with React methods.'</span>, name) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;
  }

  <span class="comment">// Disallow defining methods more than once unless explicitly allowed.</span>
  <span class="keyword">if</span> (proto.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'ReactClassInterface: You are attempting to define '</span> + <span class="string">'`%s` on your component more than once. This conflict may be due '</span> + <span class="string">'to a mixin.'</span>, name) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;
  }
}

<span class="comment">/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classses.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">mixSpecIntoComponent</span><span class="params">(Constructor, spec)</span> {</span>
  <span class="keyword">if</span> (!spec) {
    <span class="keyword">return</span>;
  }

  !(<span class="keyword">typeof</span> spec !== <span class="string">'function'</span>) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'ReactClass: You\'re attempting to '</span> + <span class="string">'use a component class or function as a mixin. Instead, just use a '</span> + <span class="string">'regular object.'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;
  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'ReactClass: You\'re attempting to '</span> + <span class="string">'use a component as a mixin. Instead, just use a regular object.'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;

  <span class="keyword">var</span> proto = Constructor.prototype;

  <span class="comment">// By handling mixins before any other properties, we ensure the same</span>
  <span class="comment">// chaining order is applied to methods with DEFINE_MANY policy, whether</span>
  <span class="comment">// mixins are listed before or after these methods in the spec.</span>
  <span class="keyword">if</span> (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> spec) {
    <span class="keyword">if</span> (!spec.hasOwnProperty(name)) {
      <span class="keyword">continue</span>;
    }

    <span class="keyword">if</span> (name === MIXINS_KEY) {
      <span class="comment">// We have already handled mixins in a special case above.</span>
      <span class="keyword">continue</span>;
    }

    <span class="keyword">var</span> property = spec[name];
    validateMethodOverride(proto, name);

    <span class="keyword">if</span> (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } <span class="keyword">else</span> {
      <span class="comment">// Setup methods on prototype:</span>
      <span class="comment">// The following member methods should not be automatically bound:</span>
      <span class="comment">// 1. Expected ReactClass methods (in the "interface").</span>
      <span class="comment">// 2. Overridden methods (that were mixed in).</span>
      <span class="keyword">var</span> isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      <span class="keyword">var</span> isAlreadyDefined = proto.hasOwnProperty(name);
      <span class="keyword">var</span> isFunction = <span class="keyword">typeof</span> property === <span class="string">'function'</span>;
      <span class="keyword">var</span> shouldAutoBind = isFunction &amp;&amp; !isReactClassMethod &amp;&amp; !isAlreadyDefined &amp;&amp; spec.autobind !== <span class="literal">false</span>;

      <span class="keyword">if</span> (shouldAutoBind) {
        <span class="keyword">if</span> (!proto.__reactAutoBindMap) {
          proto.__reactAutoBindMap = {};
        }
        proto.__reactAutoBindMap[name] = property;
        proto[name] = property;
      } <span class="keyword">else</span> {
        <span class="keyword">if</span> (isAlreadyDefined) {
          <span class="keyword">var</span> specPolicy = ReactClassInterface[name];

          <span class="comment">// These cases should already be caught by validateMethodOverride.</span>
          !(isReactClassMethod &amp;&amp; (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'ReactClass: Unexpected spec policy %s for key %s '</span> + <span class="string">'when mixing in component specs.'</span>, specPolicy, name) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;

          <span class="comment">// For methods which are defined more than once, call the existing</span>
          <span class="comment">// methods before calling the new property, merging if appropriate.</span>
          <span class="keyword">if</span> (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
            proto[name] = createMergedResultFunction(proto[name], property);
          } <span class="keyword">else</span> <span class="keyword">if</span> (specPolicy === SpecPolicy.DEFINE_MANY) {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } <span class="keyword">else</span> {
          proto[name] = property;
          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
            <span class="comment">// Add verbose displayName to the function, which helps when looking</span>
            <span class="comment">// at profiling tools.</span>
            <span class="keyword">if</span> (<span class="keyword">typeof</span> property === <span class="string">'function'</span> &amp;&amp; spec.displayName) {
              proto[name].displayName = spec.displayName + <span class="string">'_'</span> + name;
            }
          }
        }
      }
    }
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">mixStaticSpecIntoComponent</span><span class="params">(Constructor, statics)</span> {</span>
  <span class="keyword">if</span> (!statics) {
    <span class="keyword">return</span>;
  }
  <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> statics) {
    <span class="keyword">var</span> property = statics[name];
    <span class="keyword">if</span> (!statics.hasOwnProperty(name)) {
      <span class="keyword">continue</span>;
    }

    <span class="keyword">var</span> isReserved = (name <span class="keyword">in</span> RESERVED_SPEC_KEYS);
    !!isReserved ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'ReactClass: You are attempting to define a reserved '</span> + <span class="string">'property, `%s`, that shouldn\'t be on the "statics" key. Define it '</span> + <span class="string">'as an instance property instead; it will still be accessible on the '</span> + <span class="string">'constructor.'</span>, name) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;

    <span class="keyword">var</span> isInherited = (name <span class="keyword">in</span> Constructor);
    !!isInherited ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'ReactClass: You are attempting to define '</span> + <span class="string">'`%s` on your component more than once. This conflict may be '</span> + <span class="string">'due to a mixin.'</span>, name) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;
    Constructor[name] = property;
  }
}

<span class="comment">/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">mergeIntoWithNoDuplicateKeys</span><span class="params">(one, two)</span> {</span>
  !(one &amp;&amp; two &amp;&amp; <span class="keyword">typeof</span> one === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> two === <span class="string">'object'</span>) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;

  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> two) {
    <span class="keyword">if</span> (two.hasOwnProperty(key)) {
      !(one[key] === <span class="literal">undefined</span>) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'mergeIntoWithNoDuplicateKeys(): '</span> + <span class="string">'Tried to merge two objects with the same key: `%s`. This conflict '</span> + <span class="string">'may be due to a mixin; in particular, this may be caused by two '</span> + <span class="string">'getInitialState() or getDefaultProps() methods returning objects '</span> + <span class="string">'with clashing keys.'</span>, key) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;
      one[key] = two[key];
    }
  }
  <span class="keyword">return</span> one;
}

<span class="comment">/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">createMergedResultFunction</span><span class="params">(one, two)</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">mergedResult</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> a = one.apply(<span class="keyword">this</span>, arguments);
    <span class="keyword">var</span> b = two.apply(<span class="keyword">this</span>, arguments);
    <span class="keyword">if</span> (a == <span class="literal">null</span>) {
      <span class="keyword">return</span> b;
    } <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="literal">null</span>) {
      <span class="keyword">return</span> a;
    }
    <span class="keyword">var</span> c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    <span class="keyword">return</span> c;
  };
}

<span class="comment">/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">createChainedFunction</span><span class="params">(one, two)</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">chainedFunction</span><span class="params">()</span> {</span>
    one.apply(<span class="keyword">this</span>, arguments);
    two.apply(<span class="keyword">this</span>, arguments);
  };
}

<span class="comment">/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">bindAutoBindMethod</span><span class="params">(component, method)</span> {</span>
  <span class="keyword">var</span> boundMethod = method.bind(component);
  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = <span class="literal">null</span>;
    <span class="keyword">var</span> componentName = component.constructor.displayName;
    <span class="keyword">var</span> _bind = boundMethod.bind;
    boundMethod.bind = <span class="function"><span class="keyword">function</span> <span class="params">(newThis)</span> {</span>
      <span class="keyword">for</span> (<span class="keyword">var</span> _len = arguments.length, args = Array(_len > <span class="number">1</span> ? _len - <span class="number">1</span> : <span class="number">0</span>), _key = <span class="number">1</span>; _key &lt; _len; _key++) {
        args[_key - <span class="number">1</span>] = arguments[_key];
      }

      <span class="comment">// User is trying to bind() an autobound method; we effectively will</span>
      <span class="comment">// ignore the value of "this" that the user is trying to use, so</span>
      <span class="comment">// let's warn.</span>
      <span class="keyword">if</span> (newThis !== component &amp;&amp; newThis !== <span class="literal">null</span>) {
        process.env.NODE_ENV !== <span class="string">'production'</span> ? warning(<span class="literal">false</span>, <span class="string">'bind(): React component methods may only be bound to the '</span> + <span class="string">'component instance. See %s'</span>, componentName) : <span class="literal">undefined</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (!args.length) {
        process.env.NODE_ENV !== <span class="string">'production'</span> ? warning(<span class="literal">false</span>, <span class="string">'bind(): You are binding a component method to the component. '</span> + <span class="string">'React does this for you automatically in a high-performance '</span> + <span class="string">'way, so you can safely remove this call. See %s'</span>, componentName) : <span class="literal">undefined</span>;
        <span class="keyword">return</span> boundMethod;
      }
      <span class="keyword">var</span> reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      <span class="keyword">return</span> reboundMethod;
    };
  }
  <span class="keyword">return</span> boundMethod;
}

<span class="comment">/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">bindAutoBindMethods</span><span class="params">(component)</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> autoBindKey <span class="keyword">in</span> component.__reactAutoBindMap) {
    <span class="keyword">if</span> (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
      <span class="keyword">var</span> method = component.__reactAutoBindMap[autoBindKey];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }
}

<span class="comment">/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */</span>
<span class="keyword">var</span> ReactClassMixin = {

  <span class="comment">/**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */</span>
  replaceState: <span class="function"><span class="keyword">function</span> <span class="params">(newState, callback)</span> {</span>
    <span class="keyword">this</span>.updater.enqueueReplaceState(<span class="keyword">this</span>, newState);
    <span class="keyword">if</span> (callback) {
      <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback);
    }
  },

  <span class="comment">/**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */</span>
  isMounted: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.updater.isMounted(<span class="keyword">this</span>);
  },

  <span class="comment">/**
   * Sets a subset of the props.
   *
   * @param {object} partialProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */</span>
  setProps: <span class="function"><span class="keyword">function</span> <span class="params">(partialProps, callback)</span> {</span>
    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
      warnSetProps();
    }
    <span class="keyword">this</span>.updater.enqueueSetProps(<span class="keyword">this</span>, partialProps);
    <span class="keyword">if</span> (callback) {
      <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback);
    }
  },

  <span class="comment">/**
   * Replace all the props.
   *
   * @param {object} newProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */</span>
  replaceProps: <span class="function"><span class="keyword">function</span> <span class="params">(newProps, callback)</span> {</span>
    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
      warnSetProps();
    }
    <span class="keyword">this</span>.updater.enqueueReplaceProps(<span class="keyword">this</span>, newProps);
    <span class="keyword">if</span> (callback) {
      <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback);
    }
  }
};

<span class="keyword">var</span> ReactClassComponent = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

<span class="comment">/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */</span>
<span class="keyword">var</span> ReactClass = {

  <span class="comment">/**
   * Creates a composite component class given a class specification.
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */</span>
  createClass: <span class="function"><span class="keyword">function</span> <span class="params">(spec)</span> {</span>
    <span class="keyword">var</span> Constructor = <span class="function"><span class="keyword">function</span> <span class="params">(props, context, updater)</span> {</span>
      <span class="comment">// This constructor is overridden by mocks. The argument is used</span>
      <span class="comment">// by mocks to assert on what gets mounted.</span>

      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
        process.env.NODE_ENV !== <span class="string">'production'</span> ? warning(<span class="keyword">this</span> <span class="keyword">instanceof</span> Constructor, <span class="string">'Something is calling a React component directly. Use a factory or '</span> + <span class="string">'JSX instead. See: https://fb.me/react-legacyfactory'</span>) : <span class="literal">undefined</span>;
      }

      <span class="comment">// Wire up auto-binding</span>
      <span class="keyword">if</span> (<span class="keyword">this</span>.__reactAutoBindMap) {
        bindAutoBindMethods(<span class="keyword">this</span>);
      }

      <span class="keyword">this</span>.props = props;
      <span class="keyword">this</span>.context = context;
      <span class="keyword">this</span>.refs = emptyObject;
      <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;

      <span class="keyword">this</span>.state = <span class="literal">null</span>;

      <span class="comment">// ReactClasses doesn't have constructors. Instead, they use the</span>
      <span class="comment">// getInitialState and componentWillMount methods for initialization.</span>

      <span class="keyword">var</span> initialState = <span class="keyword">this</span>.getInitialState ? <span class="keyword">this</span>.getInitialState() : <span class="literal">null</span>;
      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
        <span class="comment">// We allow auto-mocks to proceed as if they're returning null.</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">'undefined'</span> &amp;&amp; <span class="keyword">this</span>.getInitialState._isMockFunction) {
          <span class="comment">// This is probably bad practice. Consider warning here and</span>
          <span class="comment">// deprecating this convenience.</span>
          initialState = <span class="literal">null</span>;
        }
      }
      !(<span class="keyword">typeof</span> initialState === <span class="string">'object'</span> &amp;&amp; !Array.isArray(initialState)) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'%s.getInitialState(): must return an object or null'</span>, Constructor.displayName || <span class="string">'ReactCompositeComponent'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;

      <span class="keyword">this</span>.state = initialState;
    };
    Constructor.prototype = <span class="keyword">new</span> ReactClassComponent();
    Constructor.prototype.constructor = Constructor;

    injectedMixins.forEach(mixSpecIntoComponent.bind(<span class="literal">null</span>, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    <span class="comment">// Initialize the defaultProps property after all mixins have been merged.</span>
    <span class="keyword">if</span> (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
      <span class="comment">// This is a tag to indicate that the use of these method names is ok,</span>
      <span class="comment">// since it's used with createClass. If it's not, then it's likely a</span>
      <span class="comment">// mistake so we'll warn you to use the static property, property</span>
      <span class="comment">// initializer or constructor respectively.</span>
      <span class="keyword">if</span> (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      <span class="keyword">if</span> (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'createClass(...): Class specification must implement a `render` method.'</span>) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;

    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
      process.env.NODE_ENV !== <span class="string">'production'</span> ? warning(!Constructor.prototype.componentShouldUpdate, <span class="string">'%s has a method called '</span> + <span class="string">'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '</span> + <span class="string">'The name is phrased as a question because the function is '</span> + <span class="string">'expected to return a value.'</span>, spec.displayName || <span class="string">'A component'</span>) : <span class="literal">undefined</span>;
      process.env.NODE_ENV !== <span class="string">'production'</span> ? warning(!Constructor.prototype.componentWillRecieveProps, <span class="string">'%s has a method called '</span> + <span class="string">'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?'</span>, spec.displayName || <span class="string">'A component'</span>) : <span class="literal">undefined</span>;
    }

    <span class="comment">// Reduce time spent doing lookups by setting these on the prototype.</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> methodName <span class="keyword">in</span> ReactClassInterface) {
      <span class="keyword">if</span> (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = <span class="literal">null</span>;
      }
    }

    <span class="keyword">return</span> Constructor;
  },

  injection: {
    injectMixin: <span class="function"><span class="keyword">function</span> <span class="params">(mixin)</span> {</span>
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;</code></pre>