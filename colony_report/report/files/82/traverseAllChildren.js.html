<h1>traverseAllChildren.js</h1>
<pre><code class="lang-js"><span class="comment">/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule traverseAllChildren
 */</span>

<span class="string">'use strict'</span>;

<span class="keyword">var</span> ReactCurrentOwner = require(<span class="string">'./ReactCurrentOwner'</span>);
<span class="keyword">var</span> ReactElement = require(<span class="string">'./ReactElement'</span>);

<span class="keyword">var</span> getIteratorFn = require(<span class="string">'./getIteratorFn'</span>);
<span class="keyword">var</span> invariant = require(<span class="string">'fbjs/lib/invariant'</span>);
<span class="keyword">var</span> warning = require(<span class="string">'fbjs/lib/warning'</span>);

<span class="keyword">var</span> SEPARATOR = <span class="string">'.'</span>;
<span class="keyword">var</span> SUBSEPARATOR = <span class="string">':'</span>;

<span class="comment">/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */</span>

<span class="keyword">var</span> userProvidedKeyEscaperLookup = {
  <span class="string">'='</span>: <span class="string">'=0'</span>,
  <span class="string">':'</span>: <span class="string">'=2'</span>
};

<span class="keyword">var</span> userProvidedKeyEscapeRegex = <span class="regexp">/[=:]/g</span>;

<span class="keyword">var</span> didWarnAboutMaps = <span class="literal">false</span>;

<span class="function"><span class="keyword">function</span> <span class="title">userProvidedKeyEscaper</span><span class="params">(match)</span> {</span>
  <span class="keyword">return</span> userProvidedKeyEscaperLookup[match];
}

<span class="comment">/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">getComponentKey</span><span class="params">(component, index)</span> {</span>
  <span class="keyword">if</span> (component &amp;&amp; component.key != <span class="literal">null</span>) {
    <span class="comment">// Explicit key</span>
    <span class="keyword">return</span> wrapUserProvidedKey(component.key);
  }
  <span class="comment">// Implicit key determined by the index in the set</span>
  <span class="keyword">return</span> index.toString(<span class="number">36</span>);
}

<span class="comment">/**
 * Escape a component key so that it is safe to use in a reactid.
 *
 * @param {*} text Component key to be escaped.
 * @return {string} An escaped string.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">escapeUserProvidedKey</span><span class="params">(text)</span> {</span>
  <span class="keyword">return</span> (<span class="string">''</span> + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
}

<span class="comment">/**
 * Wrap a `key` value explicitly provided by the user to distinguish it from
 * implicitly-generated keys generated by a component's index in its parent.
 *
 * @param {string} key Value of a user-provided `key` attribute
 * @return {string}
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">wrapUserProvidedKey</span><span class="params">(key)</span> {</span>
  <span class="keyword">return</span> <span class="string">'$'</span> + escapeUserProvidedKey(key);
}

<span class="comment">/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildrenImpl</span><span class="params">(children, nameSoFar, callback, traverseContext)</span> {</span>
  <span class="keyword">var</span> type = <span class="keyword">typeof</span> children;

  <span class="keyword">if</span> (type === <span class="string">'undefined'</span> || type === <span class="string">'boolean'</span>) {
    <span class="comment">// All of the above are perceived as null.</span>
    children = <span class="literal">null</span>;
  }

  <span class="keyword">if</span> (children === <span class="literal">null</span> || type === <span class="string">'string'</span> || type === <span class="string">'number'</span> || ReactElement.isValidElement(children)) {
    callback(traverseContext, children,
    <span class="comment">// If it's the only child, treat the name as if it was wrapped in an array</span>
    <span class="comment">// so that it's consistent if the number of children grows.</span>
    nameSoFar === <span class="string">''</span> ? SEPARATOR + getComponentKey(children, <span class="number">0</span>) : nameSoFar);
    <span class="keyword">return</span> <span class="number">1</span>;
  }

  <span class="keyword">var</span> child;
  <span class="keyword">var</span> nextName;
  <span class="keyword">var</span> subtreeCount = <span class="number">0</span>; <span class="comment">// Count of children found in the current subtree.</span>
  <span class="keyword">var</span> nextNamePrefix = nameSoFar === <span class="string">''</span> ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  <span class="keyword">if</span> (Array.isArray(children)) {
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } <span class="keyword">else</span> {
    <span class="keyword">var</span> iteratorFn = getIteratorFn(children);
    <span class="keyword">if</span> (iteratorFn) {
      <span class="keyword">var</span> iterator = iteratorFn.call(children);
      <span class="keyword">var</span> step;
      <span class="keyword">if</span> (iteratorFn !== children.entries) {
        <span class="keyword">var</span> ii = <span class="number">0</span>;
        <span class="keyword">while</span> (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } <span class="keyword">else</span> {
        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
          process.env.NODE_ENV !== <span class="string">'production'</span> ? warning(didWarnAboutMaps, <span class="string">'Using Maps as children is not yet fully supported. It is an '</span> + <span class="string">'experimental feature that might be removed. Convert it to a '</span> + <span class="string">'sequence / iterable of keyed ReactElements instead.'</span>) : <span class="literal">undefined</span>;
          didWarnAboutMaps = <span class="literal">true</span>;
        }
        <span class="comment">// Iterator will provide entry [k,v] tuples rather than values.</span>
        <span class="keyword">while</span> (!(step = iterator.next()).done) {
          <span class="keyword">var</span> entry = step.value;
          <span class="keyword">if</span> (entry) {
            child = entry[<span class="number">1</span>];
            nextName = nextNamePrefix + wrapUserProvidedKey(entry[<span class="number">0</span>]) + SUBSEPARATOR + getComponentKey(child, <span class="number">0</span>);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'object'</span>) {
      <span class="keyword">var</span> addendum = <span class="string">''</span>;
      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) {
        addendum = <span class="string">' If you meant to render a collection of children, use an array '</span> + <span class="string">'instead or wrap the object using createFragment(object) from the '</span> + <span class="string">'React add-ons.'</span>;
        <span class="keyword">if</span> (children._isReactElement) {
          addendum = <span class="string">' It looks like you\'re using an element created by a different '</span> + <span class="string">'version of React. Make sure to use only one copy of React.'</span>;
        }
        <span class="keyword">if</span> (ReactCurrentOwner.current) {
          <span class="keyword">var</span> name = ReactCurrentOwner.current.getName();
          <span class="keyword">if</span> (name) {
            addendum += <span class="string">' Check the render method of `'</span> + name + <span class="string">'`.'</span>;
          }
        }
      }
      <span class="keyword">var</span> childrenString = String(children);
      !<span class="literal">false</span> ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'Objects are not valid as a React child (found: %s).%s'</span>, childrenString === <span class="string">'[object Object]'</span> ? <span class="string">'object with keys {'</span> + Object.keys(children).join(<span class="string">', '</span>) + <span class="string">'}'</span> : childrenString, addendum) : invariant(<span class="literal">false</span>) : <span class="literal">undefined</span>;
    }
  }

  <span class="keyword">return</span> subtreeCount;
}

<span class="comment">/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildren</span><span class="params">(children, callback, traverseContext)</span> {</span>
  <span class="keyword">if</span> (children == <span class="literal">null</span>) {
    <span class="keyword">return</span> <span class="number">0</span>;
  }

  <span class="keyword">return</span> traverseAllChildrenImpl(children, <span class="string">''</span>, callback, traverseContext);
}

module.exports = traverseAllChildren;</code></pre>